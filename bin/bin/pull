#!/usr/bin/perl -w
# pull - git pull wrapper

use strict;

use Getopt::Long;

my $a_force;
my $a_dryRun;
my $a_local;
my $a_verbose;
my $a_remote;
my $a_help;

sub help() {
    print STDOUT <<'HELP';

pull - git pull wrapper

USAGE:
  >> pull [pattern] [options]

Options:
  --force   (-f) Discard outstanding changes
  --dry-run (-d) Don't actually update HEAD
  --local   (-l) Don't fetch, just reset
  --remote  (-r) Use a non-origin remote
  --verbose (-v) extra logging
  --help    (-h) See this message

EXAMPLES:
  >> pull branch-name
  >> pull pr10

HELP
}

sub getFirstNonOptionArg {
    my $arg = shift @ARGV;
    if (!defined $arg) {
        return;
    }
    return ($arg =~ /^-/) ? getFirstNonOptionArg() : $arg;
}


sub runCommand($) {
    my ($command) = @_;
    open CMD, "$command |" || die "Unable to run $command: $!";
    my @output = <CMD>;
    close CMD;
    return @output;
}

MAIN: {
    GetOptions(
        'help' => \$a_help,
        'dry-run' => \$a_dryRun,
        'force' => \$a_force,
        'remote:s' => \$a_remote,
        'local' => \$a_local,
        'verbose' => \$a_verbose
    ) || (help() && exit 1);

    # show help if either arg or option is given
    my $firstArg=getFirstNonOptionArg();
    if (($firstArg && $firstArg eq "help") || defined $a_help) {
        help();
        exit 1;
    }

    my $cleanDirty = `cleandirty`;
    chomp($cleanDirty);
    if ($cleanDirty ne "") {
        if (defined $a_force) {
            if (defined $a_verbose) {
                print "forcing...\n";
            }
            `gwip`;
        } else {
            print "error: outstanding changes\n";
            exit 1;
        }
    }

    my $MAIN=`main`;
    chomp $MAIN;

    my $REMOTE="origin";
    if (defined $a_remote) {
        $REMOTE=$a_remote;
        print "remote: $REMOTE\n";
    }

    my $FILTER=$firstArg;

    if (defined $a_local) {
        if (defined $a_verbose) {
            print "skipping fetch\n";
        }
    } else {
        `git fetch --all --quiet`;
    }

    if (defined $FILTER && $FILTER =~ '^pr[\d]+$') {
        my $pr_number = substr($FILTER, 2);
        my $targetBranch = "pr-$pr_number";

        my @remoteBranches = runCommand("git branch --remote | sed 's/^  //'");
        @remoteBranches = grep(!/^$REMOTE\/HEAD /, @remoteBranches);
        @remoteBranches = grep(!/^$REMOTE\/master$/, @remoteBranches);
        @remoteBranches = grep(!/^$REMOTE\/main$/, @remoteBranches);

        `git fetch origin pull/$pr_number/head --quiet`;
        my $FH = $ENV{FETCH_HEAD};
        my $targetSha = `git rev-parse FETCH_HEAD`;
        chomp ($targetSha);

        runCommand("crumb pullf $targetSha $targetBranch");

        foreach (@remoteBranches) {
            chomp;
            my $branch = $_;
            my $branchSha = `git rev-parse $branch`;
            chomp $branchSha;
            # print "checking $branch: $branchSha $targetSha\n";
            if ($branchSha eq $targetSha) {
                # print "match: $branch\n";
                my $foundBranch = $branch;
                $foundBranch =~ s/$REMOTE\///;
                `git branch -D $foundBranch 2>/dev/null`;
                `git checkout $foundBranch`;
                exit 0;
            }
        }

        runCommand("git checkout $MAIN --quiet");
        `git branch -D $targetBranch 2>/dev/null`;
        `git checkout -b $targetBranch`;
        `git reset --hard $targetSha`;

        exit 0;
    }

    my $TARGET_BRANCH=$MAIN;
    if (defined $FILTER) {
        my @results = runCommand("git branch --all");

        my @grepResults = grep(/remotes.*${FILTER}/i, @results);

        if (scalar @grepResults == 0) {
            print "no match\n";
            exit 1;
        } elsif (scalar @grepResults > 1) {
            foreach (@grepResults) {
                my @s = split('/', $_);
                print "$s[2]";
            }
            exit 0;
        } else {
            foreach (@grepResults) {
                my @s = split('/', $_);
                $TARGET_BRANCH="$s[2]";
                chomp($TARGET_BRANCH);
                last;
            }
        }
    }

    if (defined $a_dryRun) {
        print "$TARGET_BRANCH\n";
        exit 0;
    }

    my $CURRENT_BRANCH=`git rev-parse --abbrev-ref HEAD`;
    chomp($CURRENT_BRANCH);

    if ($CURRENT_BRANCH eq $TARGET_BRANCH) {
        if (defined $a_verbose) {
            print "already on $TARGET_BRANCH\n";
        }
    } else {
        if (defined $a_verbose) {
            print "switching to $TARGET_BRANCH\n";
        }
    }
    runCommand("crumb \"switch: ${CURRENT_BRANCH} -> ${TARGET_BRANCH}\"");

    `git checkout $TARGET_BRANCH --quiet`;
    `git reset --hard $REMOTE/$TARGET_BRANCH`;

    exit 0;
}

