#!/usr/bin/perl -w
# pull - git pull wrapper

use strict;

use Getopt::Long;

my $a_force;
my $a_dryRun;
my $a_help;

sub help() {
    print STDERR <<'HELP';

pull - git pull wrapper

USAGE:
  >> pull [pattern] [options]

Options:
  --force   (-f) Discard outstanding changes
  --dry-run (-d) Don't actually update HEAD
  --help    (-h) See this message

EXAMPLES:
  >> pull branch-name

HELP
}

sub getFirstNonOptionArg {
    my $arg = shift @ARGV;
    if (!defined $arg) {
        return;
    }
    return ($arg =~ /^-/) ? getFirstNonOptionArg() : $arg;
}


sub runCommand($) {
    my ($command) = @_;
    open CMD, "$command |" || die "Unable to run $command: $!";
    my @output = <CMD>;
    close CMD;
    return @output;
}

sub confirm($) {
    my ($message)=@_;
    print $message;
    my $ok=<>;
    chomp $ok;
    return $ok;
}

MAIN: {
    GetOptions(
        'help' => \$a_help,
        'dry-run' => \$a_dryRun,
        'force' => \$a_force
    ) || (help() && exit 1);

    # show help if either arg or option is given
    my $firstArg=getFirstNonOptionArg();
    if (($firstArg && $firstArg eq "help") || defined $a_help) {
        help();
        exit 1;
    }

    my $cleanDirty = `cleandirty`;
    chomp($cleanDirty);
    if ($cleanDirty ne "clean") {
        if (defined $a_force) {
            print "forcing...\n";
            `gwip`;
        } else {
            print "error: outstanding changes\n";
            exit 1;
        }
    }

    my $MAIN=`main`;
    chomp $MAIN;
    my $REMOTE="origin";
    my $FILTER=$firstArg;

    `git fetch --all --quiet`;

    my $TARGET_BRANCH=$MAIN;
    if (defined $FILTER) {
        my @results = runCommand("git branch --all");

        my @grepResults = grep(/remotes.*${FILTER}/i, @results);

        if (scalar @grepResults == 0) {
            print "no match\n";
            exit 1;
        } elsif (scalar @grepResults > 1) {
            foreach (@grepResults) {
                my @s = split('/', $_);
                print "$s[2]";
            }
            exit 0;
        } else {
            foreach (@grepResults) {
                my @s = split('/', $_);
                $TARGET_BRANCH="$s[2]";
                chomp($TARGET_BRANCH);
                last;
            }
        }
    }

    if (defined $a_dryRun) {
        print "$TARGET_BRANCH\n";
        exit 0;
    }

    print "switching to: $TARGET_BRANCH\n";
    my $CURRENT_BRANCH=`git rev-parse --abbrev-ref HEAD`;
    chomp($CURRENT_BRANCH);
    runCommand("crumb \"switch: ${CURRENT_BRANCH} -> ${TARGET_BRANCH}\"");

    `git checkout $TARGET_BRANCH --quiet`;
    `git reset --hard $REMOTE/$TARGET_BRANCH`;

    exit 0;
}

